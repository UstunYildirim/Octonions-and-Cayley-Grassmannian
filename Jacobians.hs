module Jacobians where

import Data.List
import Data.Maybe
import ComplexNumbers (ComplexNumber, i)
import ComplexOctonions
import LaurentPolynomials
import DifferentialFormCalculus
import MatrixCalculus
import CayleyPlanes
import MaximalTorus
import EigenvalueList
import Plucker

normTransDefEqsAsPoly = map (Poly . map createTerm) normTransDefEqs where
  createTerm (var,coeff) = Term coeff [(var,1)]

localizeNewDefEqs locChart = map (simplify . localizeTo locChart) normTransDefEqsAsPoly

latexNewLocalizedDefEqs locChart = map (mapVars typeAsNewPlucker) $ localizeNewDefEqs locChart where
  typeAsNewPlucker = ("\\wil q_{"++) . (++"}")

-- we will compute the Jacobians at the origin
-- this means the quadratic terms will not contribute
-- but Plucker relations give at least quadratic
-- replacements. so unless a variable is already
-- in a local variable it will not contribute.
-- we use this shortcut to compute Jacobians
localVars locChart = tail . take 17 $ sortOn (distance locChart) allCoordinates

jacobianOfNewDefEqsAtO :: String -> Matrix ComplexNumber
jacobianOfNewDefEqsAtO locChart = Matrix . map createRow $ tail normTransDefEqs where
  createRow ls = map lookupEntry (localVars locChart) where
    lookupEntry lvar = let val = lookup lvar ls in
      if isNothing val then 0 else fromJust val

genKerOfJac locChart = map fst vecswZeroCols ++ generatorsFromNonZeroPart where
  allCols = transpose . matrixAsList $ jacobianOfNewDefEqsAtO locChart
  allInfo = zip (localVars locChart) allCols 
  (vecswZeroCols, vecswNonZeroCols) = partition test allInfo
  test = (== zeroRow) . snd
  zeroRow = head (matrixAsList (zeroMatrix 1 7))
  generatorsFromNonZeroPart = map createVectors $ matchVecs vecswNonZeroCols
  createVectors ((v1,c1),(v2,c2)) = if c1 == c2
    then v1 ++ " - " ++ v2
    else v1 ++ " + " ++ v2
  matchVecs [] = []
  matchVecs (c:cs) = if isNothing mayCol
    then matchVecs cs
    else
      (c,col):matchVecs (delete col cs)
    where
      mayCol = find (doColsPair c) cs
      col = fromJust mayCol
  doColsPair (v1,c1) (v2,c2) = (eigValLookUp v1 == eigValLookUp v2) && isColsLinDep c1 c2
  isColsLinDep c1 c2 = c1 == c2 || (map (*(-1)) c1) == c2

jacobian :: (Eq a, Num a) => [String] -> [LPoly a] -> Matrix (LPoly a)
jacobian vars polys = Matrix [[parDer var poly | var <- vars] | poly <- polys]

jacobianInLocalCoords locChart = jacobian (localVars locChart)

(regularFxdPnts, singularFxdPnts) = partition ((==12) . length . genKerOfJac) eigVecsInXmin

generatorsOfKerJforRegPnts = map (\pnt -> (fromJust $ eigValLookUp pnt, genKerOfJac pnt)) regularFxdPnts

getEigValsOfKerElements = map (fromJust . eigValLookUp . take 4)

generatorsOfKerJforRegPntswEigVals = map (\(ev,ls) -> (ev, zip (getEigValsOfKerElements ls) ls )) generatorsOfKerJforRegPnts

generatorsOfKerJforRegPntswRelativeEigVals = map (\(ev,ls) -> zip (map (* invertLMonomial ev) $ getEigValsOfKerElements ls) ls) generatorsOfKerJforRegPnts

useOneParamSG = simplify . plugInIdentity "\\mu" (Poly [Term 1 [("\\lambda", 10)]]) . plugInIdentity "\\gamma" (Poly [Term 1 [("\\lambda", 100)]])

simplifyKerwEigVal = map (map (\(eival,vec)-> (useOneParamSG eival, vec))) generatorsOfKerJforRegPntswRelativeEigVals

latexPrintKerJ (pnt, simpldLs) = (txt1 ++ txt2 ++ txt3 ++ txt4 ++ txt5 ++ txt6 ++ txt3 ++ txt4' ++ txt5' ++ txt6 ++ txt7 ++ "\n", numPos)
  where
    processSingleElem (p, v) = ["$" ++ (drop 2 $ show p) ++ "$", "$" ++ processVec v ++ "$"]
    processVec v = let wrap w = "\\partial_{" ++ w ++ "}" in if length v == 4
      then
        wrap v
      else 
        wrap (take 4 v) ++ take 3 (drop 4 v) ++ wrap (drop 7 v)
    tableT = transpose $ map processSingleElem simpldLs
    txt1 = "At $\\wil e_{" ++ pnt ++ "}$ in $\\wil U_{" ++ pnt ++ "}$, "
    txt2 = "the kernel of $\\wil J_{" ++ pnt ++ "}$ is generated by the following vectors\n"
    txt3 = "$$\\begin{tabular}{c|c|c|c|c|c|c}\n" 
    txt4 = "vector" ++ (concatMap (" & " ++) (take 6 $ last tableT)) ++ "\\\\\\hline\n"
    txt5 = "weight" ++ (concatMap (" & " ++) (take 6 $ head tableT)) ++ "\n"
    txt4' = "vector" ++ (concatMap (" & " ++) (drop 6 $ last tableT)) ++ "\\\\\\hline\n"
    txt5' = "weight" ++ (concatMap (" & " ++) (drop 6 $ head tableT)) ++ "\n"
    txt6 = "\\end{tabular}$$\n"
    txt7 = "and the number of positive weights is " ++ show numPos ++ "."
    numPos = (12-) . length . filter (elem '-') $ head tableT

latexPrintKerJs = map fst . sortOn snd . map latexPrintKerJ $ zip regularFxdPnts simplifyKerwEigVal

countOccurences _ [] = 0
countOccurences a (x:xs) = let res = countOccurences a xs in if a == x then res + 1 else res


